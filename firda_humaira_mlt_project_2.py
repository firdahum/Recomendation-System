# -*- coding: utf-8 -*-
"""Firda_Humaira_MLT_Project_2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZjugmF1T2ejgfif4iTO9qrJO_gJseTN8

# **Recommendation System - Movies**

* **Nama:** Firda Humaira
* **Email:** firdahumaira13@gmail.com
* **ID Dicoding:** firdahum

# **Project Overview**

Meningkatnya jumlah penonton bioskop sejalan dengan bertambahnya jumlah film yang diproduksi setiap tahunnya. Beragam film dengan berbagai alur cerita, genre, dan tema, baik dari industri perfilman luar negeri maupun dalam negeri, memenuhi pasar. Kondisi ini membuat penonton sering kali kebingungan dalam memilih film yang ingin ditonton, sehingga menghabiskan waktu cukup lama untuk mencari film yang sesuai. Beberapa orang mengandalkan fitur pencarian film dari berbagai situs sebagai referensi sebelum memutuskan film yang akan ditonton. Karena setiap individu memiliki preferensi yang berbeda, mereka cenderung tertarik pada film yang mirip dengan yang mereka sukai. Untuk membantu dalam hal ini, sistem rekomendasi menjadi salah satu solusi yang efektif.

Sistem rekomendasi film dapat dibuat dengan metode **content-based filtering**, yang berfokus pada kemiripan antar konten film. Dalam pendekatan ini, informasi seperti genre, kata kunci (keywords), dan sinopsis (overview) digunakan untuk mewakili setiap film dalam bentuk data tekstual. Data ini kemudian diolah menggunakan teknik TF-IDF (Term Frequency–Inverse Document Frequency) untuk mengekstraksi bobot pentingnya kata-kata dalam tiap film, dan selanjutnya tingkat kemiripan antar film dihitung menggunakan cosine similarity.

# **1. Business Understanding**

## **1.1 Problem Statements**

1. Bagaimana pengguna dapat menemukan film yang mirip dengan film favorit mereka berdasarkan isi/konten film?

2.  Apakah informasi tambahan seperti perusahaan produksi dapat digunakan untuk lebih memahami kesamaan antar film?

3. Apakah informasi berupa keywords dan overview, tanpa melibatkan genre, dapat menghasilkan perhitungan cosine similarity yang lebih akurat dalam merekomendasikan film?

## **1.2 Goals**
1. Membantu pengguna menemukan film serupa berdasarkan kesamaan konten film, bukan hanya genre atau rating.

2. Menilai apakah informasi tambahan (seperti production company) berkontribusi terhadap penentuan kesamaan film.

3. Menguji apakah hanya menggunakan keywords dan overview (tanpa genre) bisa menghasilkan rekomendasi yang lebih relevan.

## **1.3 Solution Approach**
1. Gunakan content-based filtering dengan representasi teks (genre_list, keyword, dan overview) menggunakan TF-IDF dan cosine similarity untuk menemukan film yang mirip.
2. Tambahkan fitur seperti production company ke dalam model dan uji kontribusinya terhadap peningkatan kualitas rekomendasi.

3. Bandingkan hasil cosine similarity dari model yang hanya menggunakan keywords dan overview dengan model yang juga menyertakan genre untuk mengevaluasi akurasi rekomendasi.

# **2. Data Understanding**

## **2.1 Import Library**
"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import os
import shutil
import ast
import re
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.metrics import ConfusionMatrixDisplay, accuracy_score, classification_report

"""## **2.2 Load Dataset**"""

df = pd.read_csv('/content/drive/MyDrive/movies.csv')
df

"""| **Variabel**         | **Deskripsi**                                                                                       |
| ---------------------- | --------------------------------------------------------------------------------------------------- |
| `budget`               | Anggaran produksi film (dalam USD)                                                                  |
| `genres`               | Daftar genre film (misalnya: Action, Comedy), dalam format JSON                                     |
| `homepage`             | URL website resmi film (jika ada)                                                                   |
| `id`                   | ID unik film dari TMDb                                                                              |
| `keywords`             | Kata kunci yang menggambarkan isi film, dalam format JSON                                           |
| `original_language`    | Bahasa asli film, menggunakan kode ISO 639-1. Contoh: `en` = Inggris, `fr` = Prancis, `ja` = Jepang |
| `original_title`       | Judul asli film (bisa berbeda dengan `title`)                                                       |
| `overview`             | Ringkasan atau sinopsis film                                                                        |
| `popularity`           | Skor popularitas film menurut TMDb (gabungan dari views, rating, dll)                               |
| `production_companies` | Daftar perusahaan produksi yang membuat film, dalam format JSON                                     |
| `release_date`         | Tanggal rilis film (format: YYYY-MM-DD)                                                             |
| `revenue`              | Pendapatan film secara global (dalam USD)                                                           |
| `runtime`              | Durasi film dalam menit                                                                             |
| `spoken_languages`     | Bahasa-bahasa yang digunakan dalam film, dalam format JSON                                          |
| `status`               | Status rilis film, misalnya: Released, Post Production, dll                                         |
| `tagline`              | Slogan atau tagline promosi film                                                                    |
| `title`                | Judul film (nama yang ditampilkan ke publik)                                                        |
| `vote_average`         | Rata-rata rating film dari pengguna (skala 1–10)                                                    |
| `vote_count`           | Jumlah total suara/rating yang diberikan pengguna                                                   |

"""

df.shape

df.info()

"""**Insight:**
1. Sumber dataset yang saya gunakan : [TMDB 5000 movies](https://www.kaggle.com/code/ibtesama/getting-started-with-a-movie-recommendation-system/input?select=tmdb_5000_movies.csv)
2. Dataset ini terdiri dari 4803 baris dan 20 kolom
3. Dataset ini terdiri dari 3 tipe data, yaitu: object, float64, dan int64
4. Terdapat Missing Values di variabel **homepage, release_date, runtime, dan tagline**
"""

df.describe()

"""Fungsi describe() memberikan informasi statistik pada masing-masing kolom, antara lain:

- Count adalah jumlah sampel pada data.
- Mean adalah nilai rata-rata.
- Std adalah standar deviasi.
- Min yaitu nilai minimum setiap kolom.
- 25% adalah kuartil pertama. Kuartil adalah nilai yang menandai batas interval dalam empat bagian sebaran yang sama.
- 50% adalah kuartil kedua, atau biasa juga disebut median (nilai tengah).
- 75% adalah kuartil ketiga.
- Max adalah nilai maksimum.

**Insight:**
1. Banyak Nilai 0 yang Tidak Masuk Akal

| Kolom     | Masalah                                                         |
| --------- | --------------------------------------------------------------- |
| `budget`  | Min = 0 → banyak film tidak mencantumkan anggaran               |
| `revenue` | Min = 0 → banyak film tidak mencantumkan pendapatan             |
| `runtime` | Min = 0 → ada film yang tidak punya durasi (data error/missing) |

2. Data Sangat Tidak Merata (Skewed)
   - budget, revenue, dan vote_count menunjukkan perbedaan ekstrem antara nilai minimum dan maksimum.

3. Rata-rata Durasi & Rating Film

| Kolom          | Nilai Rata-rata                                          |
| -------------- | -------------------------------------------------------- |
| `runtime`      | \~107 menit (sekitar 1 jam 47 menit)                     |
| `vote_average` | \~6.1 dari 10                                            |
| `popularity`   | Skor rata-rata \~21, tapi sangat bervariasi (maks = 875) |

  - noted: Durasi film sebagian besar normal. Rating rata-rata cenderung di angka 6–7, artinya sebagian besar film "cukup baik".

## **2.3 Exploratory Data Analysis**

### **2.3.1 Mengetahui jumlah missing values, data duplicate dan outlier**
"""

df.isnull().sum()

"""**insight:**

Terdapat missing values di dataset ini. Kemungkinan akan saya hapus karena tidak terpakai saat modeling
"""

df.duplicated().sum()

"""**insight:**

Tidak terdapat duplikasi data di dataset ini.
"""

#Cek data outlier
numeric = ['budget', 'revenue', 'runtime', 'vote_average', 'popularity', 'vote_count']
column = df [numeric]

Q1 = column.quantile(0.25)
Q3 = column.quantile(0.75)
IQR = Q3 - Q1

df_filtered = df[~((column < (Q1 - 1.5 * IQR)) | (column > (Q3 + 1.5 * IQR))).any(axis=1)]

# Buat grid 3x3
fig, axes = plt.subplots(nrows=2, ncols=3, figsize=(15, 12))
fig.suptitle('Boxplot of Numerical Features', fontsize=16)

# Flatten axes supaya bisa di-loop
axes = axes.flatten()

# Loop fitur dan plot
for i, feature in enumerate(column):
    sns.boxplot(data=df_filtered, x=feature, ax=axes[i], color='skyblue')
    axes[i].set_title(f'{feature}')
    axes[i].set_xlabel('')

# Sembunyikan subplot yang tidak dipakai (jika jumlah fitur < jumlah grid)
for j in range(len(column), len(axes)):
    fig.delaxes(axes[j])

plt.tight_layout(rect=[0, 0, 1, 0.96])  # Agar tidak ketimpa judul
plt.show()

numeric = ['budget', 'revenue', 'runtime', 'vote_average', 'popularity', 'vote_count']
categoric = ['original_language', 'status', 'genres', 'keywords', 'production_companies', 'production_countries', 'spoken_languages']

"""- Yang tidak dimasukkan ke numeric atau categoric :
  - **id**
  - **title**
  - **original_title**
  - **tagline**
  - **homepage**
  - **overview**
  - **release_date**
  

  | **Kolom**        | **Tipe Data**    | **Alasan Tidak Termasuk**                                                                                                                                    |
| ---------------- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `id`             | Integer          | Merupakan **ID unik** film, tidak punya makna statistik atau kategorikal. Tidak digunakan untuk analisis atau pemodelan.                                     |
| `title`          | String           | **Judul film**, bersifat unik per film. Tidak berguna sebagai fitur numerik/kategorikal.                                                                     |
| `original_title` | String           | Sama seperti `title`, bersifat unik dan bukan fitur yang representatif secara statistik.                                                                     |
| `homepage`       | String (URL)     | Merupakan **link URL resmi** film. Unik per film, tidak bermakna untuk pemodelan atau analisis.                                                              |
| `tagline`        | String           | Kalimat promosi (slogan), bersifat unik atau kosong. Jarang berguna langsung dalam analisis kategorikal atau numerik.                                        |
| `overview`       | String (teks)    | Deskripsi panjang (text bebas). Tidak termasuk `categoric` karena bukan kategori diskrit, dan tidak bisa diukur seperti `numeric`. Bisa digunakan untuk NLP. |
| `release_date`   | String (tanggal) | Format tanggal (`YYYY-MM-DD`), bukan numerik secara langsung, dan bukan kategorikal. Perlu diubah dulu (misalnya jadi tahun atau bulan) untuk digunakan.     |

### **2.3.2 Distribusi Kolom Numerik**
"""

for col in numeric:
    plt.figure(figsize=(6, 4))
    sns.histplot(df[col], kde=True)
    plt.title(f'Distribusi {col}')
    plt.show()

"""**Insight:**

- Budget & Revenue: Distribusinya sangat miring ke kanan; sebagian besar film punya nilai kecil, hanya sedikit yang sangat besar.

- Runtime: Distribusi mendekati normal, mayoritas film berdurasi sekitar 100 menit.

- Vote Average: Simetris, sebagian besar film punya rating sekitar 6–7.

- Popularity & Vote Count: Sama seperti budget dan revenue, miring ke kanan; hanya sebagian kecil film yang sangat populer dan banyak mendapat suara.

kesimpulan

Sebagian besar film dalam dataset memiliki karakteristik yang cukup umum—runtime sekitar 100 menit, rating rata-rata, serta nilai popularitas, budget, dan pendapatan yang relatif rendah. Hanya sebagian kecil film yang tergolong sangat sukses atau populer, terlihat dari adanya outlier pada distribusi budget, revenue, popularity, dan vote count. Pola ini menggambarkan bahwa industri film didominasi oleh beberapa blockbuster saja, sedangkan mayoritas film beroperasi pada skala yang lebih kecil.

### **2.3.3 Korelasi Antar Kolom Numerik**
"""

sns.heatmap(df[numeric].corr(), annot=True, cmap='coolwarm')
plt.title('Matriks Korelasi')
plt.show()

"""**Insight:**

1. vote_count punya korelasi kuat dengan
    - revenue (0.78) → film yang banyak diberi suara (vote) cenderung menghasilkan pendapatan lebih tinggi.
    - popularity (0.78) → film yang populer cenderung lebih banyak diberi rating.
    - budget (0.59) → film dengan anggaran lebih besar umumnya juga mendapat lebih banyak vote.

2. budget dan revenue sangat berkorelasi (0.73)
    - Semakin besar anggaran produksi, cenderung semakin besar pendapatannya.

3. vote_average (rating rata-rata) tidak berkorelasi tinggi dengan apapun
    - Korelasi tertinggi hanya dengan runtime (0.38) dan vote_count (0.31) → artinya film yang panjang dan banyak di-vote sedikit lebih cenderung dapat rating bagus, tapi tidak signifikan.

4. runtime korelasinya lemah ke semua variabel:
    - Film berdurasi panjang tidak menjamin revenue, popularitas, atau rating tinggi.

### **2.3.4 Rata-rata rating per genre**

Karena genres berupa JSON string, perlu di-parse dulu:
"""

def extract_genres(g):
    try:
        genres = ast.literal_eval(g)
        return [item['name'] for item in genres]
    except:
        return []

df['genre_list'] = df['genres'].apply(extract_genres)

"""Lalu eksplor:"""

from collections import Counter

genre_flat = [genre for sublist in df['genre_list'] for genre in sublist]
Counter(genre_flat).most_common(10)

genre_rating = {}

for genre in genre_flat:
    mask = df['genre_list'].apply(lambda x: genre in x)
    genre_rating[genre] = df[mask]['vote_average'].mean()

pd.Series(genre_rating, name='rata-rata').sort_values(ascending=False).head(10)

# Ubah genre_rating jadi DataFrame
genre_rating_df = pd.Series(genre_rating, name='rata-rata').sort_values(ascending=False).reset_index()
genre_rating_df.rename(columns={'index': 'genre'}, inplace=True)

# Plot
plt.figure(figsize=(10,6))
sns.barplot(data=genre_rating_df.head(10), x='rata-rata', y='genre', palette='viridis')

plt.title('Top 10 Genre dengan Rata-rata Rating Tertinggi')
plt.xlabel('Rata-rata Rating')
plt.ylabel('Genre')
plt.xlim(5.5, 7.5)
plt.grid(axis='x', linestyle='--', alpha=0.5)
plt.tight_layout()
plt.show()

"""**Insight:**
- Genre memengaruhi kualitas persepsi film dari sisi penonton.
- Genre dengan tema berat dan emosional (History, War, Drama) cenderung dinilai lebih tinggi.
- Wawasan ini bisa membantu sistem rekomendasi memprioritaskan genre tertentu untuk pengguna dengan preferensi tinggi terhadap rating.

# **3. Data Preparation**

## **3.1 Data Cleaning**

### **3.1.1 Format Tidak Konsisten / JSON dalam String**

Melakukan penanganan terhadap format yang tidak konsisten atau JSON dalam string itu penting karena beberapa alasan krusial dalam proses pengolahan data.
Alasan:
1. Parsing dan Ekstraksi Data Gagal:
  - Banyak kolom (misalnya genres, keywords, production_companies) disimpan dalam format string yang terlihat seperti JSON (misalnya: "[{'id': 28, 'name': 'Action'}]"). Jika tidak dikonversi ke struktur Python (seperti list atau dict), kita tidak bisa mengakses nilai-nilainya secara efektif.

2. Analisis Terhambat:
  - Jika struktur data tidak dibersihkan, kita tidak bisa menghitung jumlah genre, menghitung berapa film mengandung genre "Action", atau melakukan agregasi berdasarkan kategori tertentu.

3. Inconsistent Format = Error Saat Modeling:
  - Format yang tidak konsisten (misal kadang pakai kutip tunggal ', kadang kutip ganda ", atau bahkan format tidak lengkap) bisa menyebabkan error saat parsing, yang berdampak pada pipeline analisis atau training model machine learning.
"""

def extract_names(text):
    try:
        items = ast.literal_eval(text)
        return [item['name'] for item in items]
    except:
        return []

# Kolom-kolom yang perlu diproses
json_cols = ['genres', 'keywords', 'production_companies', 'production_countries', 'spoken_languages']

# Terapkan ke setiap kolom
for col in json_cols:
    df[col] = df[col].apply(extract_names)

# lihat hasilnya
print(df[json_cols].head(3))

"""### **3.1.2 Menghapus kolom yang tidak relevan untuk Sistem Rekomendasi (Content-based Filtering)**

Content-Based Filtering adalah metode sistem rekomendasi yang memberikan saran berdasarkan kemiripan konten antar item (dalam hal ini, film).
Artinya, sistem ini melihat fitur-fitur yang menjelaskan isi atau karakteristik film, seperti:

- overview (sinopsis)

- genres (genre film)

- keywords (kata kunci)

jadi, saya akan menghapus variabel yang tidak relevan
"""

columns_to_drop = ['id', 'homepage', 'tagline', 'original_title',
                   'release_date', 'status', 'vote_count', 'vote_average',
                   'popularity', 'budget', 'runtime', 'genres', 'original_language',
                   'revenue', 'spoken_languages','production_countries']

# Hapus kolom dari DataFrame
df.drop(columns=columns_to_drop, inplace=True)
df.columns

df.head()

df.info()

"""**Insight:**

Masih terdapat missing values di kolom 'overview'

### **3.1.3 Menangani Missing Values**
"""

df = df.dropna(subset=['overview'])

df.info()

"""**Insight:**

Missing values sudah tidak ada

# **4. Modeling and Result**

## **4.1 Model Development dengan Content Based Features**

### **TF-IDF**

Pada proyek saya ini perlu menggunakan TF-IDF (Term Frequency - Inverse Document Frequency) karena metode ini sangat efektif dalam mengolah data teks untuk sistem rekomendasi berbasis konten (content-based filtering)

TF-IDF digunakan karena bisa mengekstrak makna penting dari teks, mengabaikan kata tidak penting, dan mengubah teks menjadi format numerik yang siap untuk menghitung kemiripan antar item.
"""

# Gabungkan fitur teks
df['combined_features'] = df['overview'] + ' ' + df['keywords'].apply(lambda x: ' '.join(x)) + ' ' + df['genre_list'].apply(lambda x: ' '.join(x))

tfidf = TfidfVectorizer(stop_words='english')
tfidf_matrix = tfidf.fit_transform(df['combined_features'])

"""### **Cosine Similarity**"""

# Cosine Similarity
cosine_sim = cosine_similarity(tfidf_matrix, tfidf_matrix)
cosine_sim

# Membuat dataframe dari variabel cosine_sim
cosine_sim_df = pd.DataFrame(cosine_sim, index=df['title'], columns=df['title'])
print('Shape:', cosine_sim_df.shape)

# Melihat similarity matrix
cosine_sim_df.sample(5, axis=1).sample(20, axis=0)

"""**Insight:**

Cosine similarity matrix memungkinkan kita mengukur dan membandingkan kemiripan antar film secara numerik. Dari sampel data yang ditampilkan, tampak bahwa sebagian besar film memiliki kesamaan yang rendah satu sama lain, menandakan keberagaman tema dan genre. Namun, ada juga beberapa pasangan film dengan kemiripan relatif tinggi, yang menunjukkan bahwa model berhasil menangkap hubungan semantik atau genre tertentu antar film. Matriks ini sangat berguna untuk sistem rekomendasi berbasis konten (content-based filtering), di mana film yang mirip dengan film tertentu bisa direkomendasikan kepada pengguna.

## **4.2 Penerapan**
"""

def recommend(title, cosine_sim):
    idx = df[df['title'] == title].index[0]
    sim_scores = list(enumerate(cosine_sim[idx]))
    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)[1:6]  # ambil top-5
    movie_indices = [i[0] for i in sim_scores]

    # Ambil skor similarity-nya juga
    similarity_scores = [score for _, score in sim_scores]

    print(f"Rekomendasi 5 film yang se tema dengan: '{title}'\n")

    # Ambil data film + tambahkan skor cosine similarity
    result = df[['title', 'genre_list', 'keywords', 'overview']].iloc[movie_indices].copy()
    result['cosine_score'] = similarity_scores

    return result

df[df['title'] == 'Avatar'][['genre_list', 'keywords', 'overview']]

title = 'Avatar'
recommend(title, cosine_sim=cosine_sim)

"""**Insight**:
1. Kesamaan Genre

    - Hampir semua film yang direkomendasikan memiliki genre Science Fiction dan beberapa juga memiliki unsur Action dan Thriller, sama seperti Avatar.

    - Ini menunjukkan bahwa sistem berhasil menangkap kesamaan genre utama dari Avatar dengan film lain.

2. Kemiripan Kata Kunci & Tema Cerita:

    - Keyword seperti spacecraft, alien, space marine, android, extraterrestrial sangat mendekati dunia dan tema Avatar.

    - Banyak film juga mengambil latar luar angkasa atau eksplorasi luar dunia — cocok dengan dunia fiksi ilmiah imajinatif ala Avatar.

3. Variasi dan Relevansi Film:

    - Judul seperti Aliens, Moonraker, dan Mission to Mars memang berkutat di genre eksplorasi luar angkasa dan konflik antar spesies atau teknologi canggih.

    - Spaceballs muncul sebagai film dengan elemen sci-fi, namun bernuansa komedi parodi, yang bisa diperdebatkan relevansinya tergantung konteks pengguna.
"""

df[df['title'] == 'Tangled'][['genre_list', 'keywords', 'overview']]

title = 'Tangled'
recommend(title, cosine_sim=cosine_sim)

"""**Insight:**
1. Genre yang Serupa

    - Film yang direkomendasikan mayoritas memiliki genre Fantasy, Family, Comedy, dan bahkan ada yang Animation seperti Shrek 2.

    - Ini menunjukkan bahwa sistem rekomendasi berhasil mengidentifikasi genre utama dari Tangled dan mencari film dengan genre sejenis.

2. Kemiripan Tema/Kata Kunci

    - Film seperti Ella Enchanted dan Enchanted memiliki keyword seperti "magic", "fairy tale", dan "princess" — sangat relevan dengan karakteristik Tangled.

    - Hal ini menunjukkan bahwa metode TF-IDF + Cosine Similarity cukup efektif menangkap konteks kata dan tema cerita.

3. Kualitas Hasil Rekomendasi

    - Judul seperti Into the Woods dan Enchanted memang punya kesamaan dunia fantasi dan musikal, cocok untuk penonton Tangled.

    - Namun ada juga judul seperti Out of Inferno (dengan genre Action) yang kurang relevan. Ini mungkin terjadi karena keterbatasan informasi pada fitur teks, atau karena elemen umum seperti "heroism" atau "rescue" membuatnya dianggap mirip.
"""

df[df['title'] == 'Inception'][['genre_list', 'keywords', 'overview']]

title = 'Inception'
recommend(title, cosine_sim=cosine_sim)

"""**Insight:**

1. Nilai cosine score relatif rendah (maks ~0.12)
  - Ini menandakan bahwa tidak ada film yang sangat mirip secara konten dengan Inception dalam dataset ini. Namun, beberapa film memiliki cukup banyak elemen serupa untuk dijadikan rekomendasi.

2. Kemiripan berdasarkan genre dan tema kompleks
  - Film seperti Cypher dan Blood and Wine memiliki genre seperti Thriller, Science Fiction, dan Drama, yang juga dimiliki oleh Inception. Ini menunjukkan bahwa model menekankan pada genre dan elemen cerita (misalnya: "undercover", "robbery", "double life", dll) dalam menentukan kemiripan.

3. Tidak semua film memiliki keywords yang lengkap
  - Misalnya, The Helix... Loaded dan Duplex tidak memiliki data keywords, namun tetap masuk rekomendasi karena overview dan genre masih relevan.

4. Beberapa rekomendasi tampak kurang relevan secara tematik
  - Misalnya, Crouching Tiger, Hidden Dragon lebih ke arah aksi dan seni bela diri, berbeda secara substansi dengan tema psikologis dan mimpi seperti di Inception. Ini bisa terjadi karena kemiripan kata dalam deskripsi atau genre overlap seperti Action dan Drama.

# **5. Evaluation**

**Metrik yang digunakan: Cosine Similarity**

Cosine Similarity mengukur kemiripan antar dua vektor dengan menghitung sudut kosinus antara mereka. Dalam konteks ini, vektor berasal dari representasi TF-IDF dari kombinasi fitur (overview, genre, keywords)

Formula:

    cosine_similarity (A,B)=  (A ⋅ B) / (∥A∥ ∥B∥)


- Nilai berkisar antara 0 hingga 1.

- Semakin tinggi nilai cosine similarity, semakin mirip kontennya.


Dalam proyek ini, sistem rekomendasi menggunakan metrik Cosine Similarity untuk menghitung kemiripan antar film berdasarkan fitur teks (overview, genre, keywords, dan production_companies) yang telah diolah menggunakan TF-IDF vectorization.

Cosine Similarity dipilih karena mampu mengukur kesamaan dokumen secara efektif meskipun panjang teksnya berbeda.

Evaluasi dilakukan dengan mengamati relevansi hasil rekomendasi, misalnya film yang direkomendasikan untuk "Avatar" sebagian besar memiliki genre dan kata kunci serupa seperti "Science Fiction", "alien", "space", dan teknologi luar angkasa, sehingga relevan dengan konteks film tersebut.

Meskipun tidak menggunakan metrik seperti Precision@K atau Recall@K karena tidak ada data preferensi user, evaluasi berdasarkan interpretasi konten sudah cukup menggambarkan bahwa model bekerja sesuai harapan.

**Metrik yang digunakan: TF-IDF**

Nilai TF-IDF diperoleh dari penggabungan dua komponen, yaitu Term Frequency (TF) yang mengukur seberapa sering suatu istilah muncul dalam dokumen, dan Inverse Document Frequency (IDF) yang menilai seberapa jarang istilah tersebut muncul di seluruh dokumen. Gabungan keduanya memberikan bobot yang mencerminkan pentingnya istilah dalam konteks dokumen tertentu.

                𝑡𝑓(𝑡, 𝑑) = 1 + log (𝑓𝑡𝑑)
Di mana:
- 𝑡𝑓(𝑡, 𝑑) = Nilai TF untuk istilah t dalam dokumen d
- 𝑓𝑡𝑑 = Jumlah istilah t dalam dokumen d

Nilai IDF untuk suatu istilah di dalam koleksi dapat dihitung menggunakan persamaan

                𝑖𝑑𝑓(𝑡) = log ( N / (𝑑𝑓𝑡))
Di mana:
- 𝑖𝑑𝑓(𝑡) = Nilai IDF untuk istilah t dalam koleksi
- 𝑑𝑓𝑡 = Jumlah dokumen yang mengandung istilah t
- N = Total jumlah dokumen dalam koleksi

Bobot TF-IDF untuk istilah t di dalam dokumen d dapat dihitung menggunakan persamaan

                𝑡𝑓 − 𝑖𝑑𝑓(𝑡, 𝑑) = tf(𝑡, 𝑑) × 𝑖𝑑𝑓(𝑡)
Di mana:
- 𝑡𝑓 − 𝑖𝑑𝑓(𝑡, 𝑑) = Nilai TF-IDF untuk istilah t untuk dukumen d dalam koleksi
- 𝑡𝑓(𝑡, 𝑑) = Nilai TF untuk istilah t dalam dokumen d
- 𝑖𝑑𝑓(𝑡) = Nilai IDF untuk istilah t dalam koleksi

# **Solving the Problems**

### **1. Bagaimana pengguna dapat menemukan film yang mirip dengan film favorit mereka berdasarkan isi/konten film?**
"""

def recommend(title, cosine_sim):
    idx = df[df['title'] == title].index[0]
    sim_scores = list(enumerate(cosine_sim[idx]))
    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)[1:11]

    movie_indices = [i[0] for i in sim_scores]
    similarity_scores = [i[1] for i in sim_scores]

    print(f"Rekomendasi 10 Film yang mirip berdasarkan konten dengan: '{title}'\n")

    result = df[['title', 'genre_list', 'keywords', 'overview']].iloc[movie_indices].copy()
    result['cosine_score'] = similarity_scores

    return result

recommend('Jurassic World', cosine_sim)

"""**Intepretasi**

Berdasarkan gambar rekomendasi film yang mirip dengan Jurassic World, dapat disimpulkan bahwa sistem rekomendasi berbasis konten mampu memberikan hasil yang sangat relevan pada urutan teratas, terutama ketika film-film tersebut berasal dari waralaba atau franchise yang sama, seperti Jurassic Park, The Lost World, dan Jurassic Park III. Ketiga film ini memiliki skor kemiripan yang tinggi karena kesamaan yang kuat dalam genre, kata kunci, dan alur cerita.

Namun, setelah tiga besar, kualitas rekomendasi mulai menurun secara signifikan. Film-film seperti Vacation, The Nut Job, hingga Adventureland yang muncul selanjutnya memiliki tema, genre, dan konten yang tidak lagi selaras dengan Jurassic World, meskipun secara teknis masih memiliki elemen umum seperti “adventure” atau “comedy”.

Penurunan skor cosine similarity yang drastis ini menunjukkan bahwa model memiliki keterbatasan dalam mempertahankan relevansi ketika fitur-fitur yang digunakan terlalu umum. Oleh karena itu, untuk meningkatkan akurasi terutama di luar film-film yang sangat mirip, perlu dipertimbangkan penambahan fitur yang lebih mendalam seperti karakter, setting, atau analisis sentimen dari ulasan pengguna.

### **2. Apakah informasi tambahan seperti perusahaan produksi dapat digunakan untuk lebih memahami kesamaan antar film?**

> Add blockquote
"""

# Gabungkan fitur-fitur konten
df['combined_features'] = df['genre_list'].astype(str) + ' ' + \
                          df['keywords'].astype(str) + ' ' + \
                          df['overview'].astype(str) + ' ' + \
                          df['production_companies'].astype(str)

# Vektorisasi teks gabungan
tfidf = TfidfVectorizer(stop_words='english')
tfidf_matrix = tfidf.fit_transform(df['combined_features'])

# Hitung cosine similarity
cosine_sim = cosine_similarity(tfidf_matrix, tfidf_matrix)

# Fungsi rekomendasi berdasarkan title
def recommend(title, cosine_sim=cosine_sim, df=df):
    idx = df[df['title'] == title].index[0]
    sim_scores = list(enumerate(cosine_sim[idx]))
    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)[1:6]
    movie_indices = [i[0] for i in sim_scores]
    cosine_scores = [i[1] for i in sim_scores]

    print(f"Rekomendasi 5 film mirip berdasarkan gabungan konten dengan: '{title}'\n")

    result = df[['title', 'genre_list', 'keywords', 'overview', 'production_companies']].iloc[movie_indices].copy()
    result['cosine_score'] = cosine_scores

    return result

df[df['title'] == 'Tangled'][['genre_list', 'keywords', 'overview']]

recommend('Tangled', cosine_sim)

df[df['title'] == 'Avatar'][['genre_list', 'keywords', 'overview']]

recommend('Avatar', cosine_sim)

"""**Intepretasi:**

Menambahkan informasi production_companies dapat meningkatkan akurasi rekomendasi, tetapi tergantung konteks film.

| Kondisi Film                                                 | Dampak Penambahan `production_companies`                                                                                          |
| ------------------------------------------------------------ | --------------------------------------------------------------------------------------------------------------------------------- |
| **Film dengan gaya khas studio** (misal: *Tangled* - Disney) | **Meningkatkan akurasi** karena banyak film dari studio tersebut punya tone, genre, dan target audiens yang mirip.              |
| **Film dengan genre kuat dan lebih umum** (misal: *Avatar*)  | **Peningkatan akurasi terbatas**, karena genre seperti sci-fi lebih ditentukan oleh cerita, visual, dan tema, bukan studionya. |


Penambahan **production_companies** dapat meningkatkan akurasi, terutama untuk film yang dipengaruhi kuat oleh gaya studio (misalnya animasi Disney). Namun, untuk film dengan kekuatan utama di alur cerita atau genre luas seperti sci-fi, pengaruhnya lebih kecil.

### **3. Apakah informasi berupa keywords dan overview, tanpa melibatkan genre, dapat menghasilkan perhitungan cosine similarity yang lebih akurat dalam merekomendasikan film?**
"""

# Gabungkan hanya keywords dan overview
df['content_features'] = df['keywords'].astype(str) + ' ' + df['overview'].astype(str)

# Vektorisasi TF-IDF
tfidf = TfidfVectorizer(stop_words='english')
tfidf_matrix = tfidf.fit_transform(df['content_features'])

# Hitung cosine similarity
cosine_sim = cosine_similarity(tfidf_matrix, tfidf_matrix)

# Fungsi rekomendasi
def recommend(title, cosine_sim=cosine_sim, df=df):
    idx = df[df['title'] == title].index[0]
    sim_scores = list(enumerate(cosine_sim[idx]))
    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)[1:6]
    movie_indices = [i[0] for i in sim_scores]
    cosine_scores = [i[1] for i in sim_scores]

    results = df[['title', 'keywords', 'overview']].iloc[movie_indices].copy()
    results['cosine_score'] = cosine_scores

    print(f"\nRekomendasi 5 film mirip berdasarkan keywords + overview (tanpa genre): '{title}'")
    return results

# Contoh penggunaan
recommend('Inception')

"""**Intepretasi:**

- Perbandingan Dua Pendekatan

| Pendekatan   | Fitur yang Digunakan               | Nilai Cosine Tertinggi | Judul Paling Mirip (Top 1) |
| ------------ | ---------------------------------- | ---------------------- | -------------------------- |
| Tanpa Genre  | `keywords + overview`              | 0.104511               | **Blood and Wine**         |
| Dengan Genre | `genre_list + keywords + overview` | 0.123394               | **Cypher**                 |

Insight Utama
- Dengan Genre Lebih Akurat

    - Nilai cosine similarity rata-rata lebih tinggi ketika genre disertakan, yang menunjukkan bahwa genre membantu memperkuat konteks tematik antar film.

    - Film seperti Cypher muncul di posisi atas pada kedua pendekatan, tapi skornya lebih tinggi saat genre digunakan.

- Tanpa Genre Lebih Bebas Tapi Kurang Tepat:

    - Saat hanya menggunakan keywords dan overview, hasil rekomendasi menjadi lebih bervariasi dan kurang relevan secara genre. Misalnya, Pitch Perfect 2 muncul meski jauh dari nuansa sci-fi/thriller seperti Inception.

    - Ini menunjukkan bahwa meskipun ada kemiripan deskripsi, genre tetap penting dalam menyaring konteks film yang tepat.

**Kesimpulan**

Informasi genre berperan penting dalam meningkatkan akurasi rekomendasi film. Tanpa genre, rekomendasi bisa melenceng ke film yang deskripsinya mirip secara permukaan, tapi tidak sejalan dari sisi tema atau pengalaman menonton.

# **Referensi**
1. Arfisko, H. H., & Wibowo, A. T. (2022). Sistem Rekomendasi Film Menggunakan Metode Hybrid Collaborative Filtering Dan Content-Based Filtering. eProceedings of Engineering, 9(3).

2. Fajriansyah, M., Adikara, P. P., & Widodo, A. W. (2021). Sistem Rekomendasi Film Menggunakan Content Based Filtering. Jurnal Pengembangan Teknologi Informasi Dan Ilmu Komputer, 5(6), 2188–2199. Diambil dari https://j-ptiik.ub.ac.id/index.php/j-ptiik/article/view/9163

3. Saputra, J. M. A., Huizen, L. M., & Arianto, D. B. (2024). Sistem Rekomendasi Film pada Platform Streaming Menggunakan Metode Content-Based Filtering. Jurnal Transformatika, 22(1), 10-21.
"""